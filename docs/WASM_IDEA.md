# WASM Plugin Architecture Proposal

This document outlines a proposal for a **WebAssembly (WASM) based plugin system** for `metallic-foundry`. This architecture allows third-party developers to extend the engine with generic **Workflow Ops** and high-performance **Custom Kernels** (Rust + Metal) entirely at runtime, without recompiling the engine.

## Core Philosophy: "User-Mode Driver"

The central design principle is that the **WASM plugin acts as a controller**, not a compute engine.
- **Compute (Heavy)**: Happens on the GPU (Metal) or Host CPU (Tensors). managed by `metallic-foundry`.
- **Control (Light)**: Happens in WASM. The plugin makes decisions and issues "commands" (e.g., "dispatch this kernel", "resize this tensor") via a lightweight Host API.

This ensures that the WASM execution overhead is negligible compared to the workload.

---

## 1. Architecture Overview

### The Host (Metallic Foundry)
- Loads WASM modules via a runtime (e.g., `wasmtime`).
- Exposes a `Host API` (WIT interface) for resource management and kernel dispatch.
- Manages the actual `Metal` device, `CommandBuffers`, and `Tensor` memory.

### The Guest (Plugin)
- Compiled to `wasm32-unknown-unknown` (or `wasm32-wasi`).
- Depends on a lightweight **`metallic-sdk`** crate (not the full engine).
- Implements the **Guest API** (e.g., `execute_step`, `define_kernels`).

---

## 2. Refactoring Requirements: `metallic-sdk`

To make this efficient, plugins cannot depend on the massive `metallic-foundry` crate. We must extract the "API surface" into a separate crate.

### Proposed Crate Split
1.  **`metallic-macros`** (Existing):
    - Must be updated to support "Dual-Mode" code generation (see Section 4).
2.  **`metallic-sdk`** (New):
    - Contains **Traist**: `Kernel`, `Stage`, `MetalPolicy`.
    - Contains **Types**: `TensorArg`, `DispatchConfig`, `MetalType`.
    - Contains **WASM Bindings**: Hidden internal modules that map to the Host API when compiling for `wasm32`.
    - **Does NOT contain**: `objc2`, `metal-rs`, or large dependencies.

Third-party `Cargo.toml`:
```toml
[dependencies]
metallic-sdk = "0.1"  # Everything needed to write kernels/ops
```

---

## 3. Ops as WASM Modules

The goal is to let users register new `WorkflowOp` implementations (like `MyCustomSampler`) dynamically.

### WIT Interface Design
We definition a `workflow-op.wit` contract:

```wit
interface workflow-guest {
    // The entry point for the op
    execute: func(ctx-handle: u32, params-json: string) -> result<bool, string>;
}

interface workflow-host {
    // Host functions exposed to the plugin
    tensor-get: func(ctx: u32, name: string) -> u32; // result is a Handle ID
    tensor-shape: func(tensor: u32) -> list<u64>;
    
    // Dispatch a kernel
    dispatch-kernel: func(
        ctx: u32, 
        kernel-id: u32, 
        args: list<u32> // List of Tensor Handles (Buffer Args)
    );
}
```

### Rust Implementation
Using the generic `OpBuilder` pattern, the host simply proxies execution to the WASM instance.

```rust
// Host: compiler.rs
pub fn register_wasm_op(name: &str, wasm_path: &str) {
    let module = module_loader.load(wasm_path);
    register_op(name, Box::new(move |params| {
        Box::new(WasmOpProxy::new(module.clone(), params))
    }));
}
```

---

## 4. Kernels in WASM (Rust + Metal)

This is the critical piece: preserving the `metallic-foundry` developer experience (Macros, Structs, Type Safety) while running in a sandbox.

### "Dual-Mode" Macros
The macros (`#[derive(Kernel)]`, `#[derive(KernelArgs)]`) in `metallic-macros` will be updated to check the compilation target.

#### Native Mode (`target_arch != "wasm32"`)
Generates standard Metal code:
```rust
impl Kernel for MyKernel {
    fn bind(&self, encoder: &ComputeCommandEncoder) {
        encoder.set_buffer(0, self.input.as_metal_buffer(), 0);
        // ...
    }
}
```

#### WASM Mode (`target_arch = "wasm32"`)
Generates **Host API calls** via `metallic-sdk`:
```rust
impl Kernel for MyKernel {
    fn bind(&self, ctx_handle: u32) {
        // Pseudo-code generated by macro
        host_api::bind_buffer(ctx_handle, 0, self.input.handle_id());
        host_api::bind_bytes(ctx_handle, 1, &self.params.to_le_bytes()); 
    }
}
```

### Packaging Custom Kernels
A plugin WASM file will contain:
1.  **WASM Code**: The Rust logic to calculate threadgroups and bind arguments.
2.  **Metal Source**: Embedded strings (the `.metal` files).

When the plugin loads:
1.  Guest calls `host_api::register_library("my_kernel.metal")`.
2.  Host compiles the MSL asynchronously.
3.  Guest can now issue dispatch commands for functions in that library.

---

## 5. Developer Experience (Example)

A third-party developer writes the exact same code they would inside the engine.

`my-plugin/src/lib.rs`:
```rust
use metallic_sdk::*;

// 1. Define the Kernel
#[derive(Kernel, KernelArgs)]
#[kernel(source = "kernels.metal", function = "add_one")]
pub struct AddOneKernel {
    pub input: TensorArg,
    #[arg(output)]
    pub output: TensorArg,
}

// 2. Define the Op using the Kernel
#[derive(WorkflowOp)] // Wrapper macro that implements the Guest API
#[op(name = "add_one_op")]
pub struct AddOneOp {
    input_var: String,
    output_var: String,
}

impl AddOneOp {
    fn execute(&self, ctx: &mut Context) {
        let input = ctx.get_tensor(&self.input_var);
        let output = ctx.get_tensor(&self.output_var);
        
        // Dispatch!
        AddOneKernel { input, output }.dispatch(ctx);
    }
}
```

### Build Process
```bash
# Developer simply builds generic wasm
cargo build --target wasm32-unknown-unknown --release
```

### Runtime Loading
```bash
# User loads it into Foundry
metallic-cli plugin load ./target/wasm32-unknown-unknown/release/my_plugin.wasm
```

---

## 6. Summary of Work Items

1.  **Create `metallic-sdk`**: Move traits (`Kernel`, `WorkflowOp`) and essential types to a new crate with minimal dependencies.
2.  **Update `metallic-macros`**: Add `#[cfg(target_arch = "wasm32")]` branches to generate Host API calls instead of `metal-rs` calls.
3.  **Implement Host Runtime**: Add `wasmtime` (or similar) to `metallic-foundry` to load plugins and expose the `workflow-host` interface.
4.  **Serialization**: Ensure generic structs like `WorkflowStepSpec` can be passed efficiently (JSON is simplest for Config, Handles for Tensors).
