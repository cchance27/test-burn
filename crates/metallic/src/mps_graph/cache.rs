use objc2::{rc::Retained, runtime::ProtocolObject};
use objc2_foundation::{NSArray, NSMutableArray, NSMutableDictionary};
use objc2_metal::MTLDevice;
use objc2_metal_performance_shaders::MPSDataType;
use objc2_metal_performance_shaders_graph as mpsg;

use crate::{
    cache_keys::MpsGraphFusedKey, cacheable::Cacheable, caching::CacheableKernel, error::MetalError, mps_graph::multi_op::{GraphFeedBinding, GraphResultBinding, MultiOpGraphBuilder}
};

#[derive(Clone)]
pub struct CacheableMpsGraphFused {
    pub key: MpsGraphFusedKey,
    pub executable: Retained<mpsg::MPSGraphExecutable>,
    pub feed_layout: Vec<GraphFeedBinding>,
    pub result_layout: Vec<GraphResultBinding>,
    pub data_type: MPSDataType,
    pub accumulator_data_type: Option<MPSDataType>,
}

impl Cacheable for CacheableMpsGraphFused {
    type Key = MpsGraphFusedKey;

    fn cache_key(&self) -> Self::Key {
        self.key.clone()
    }

    fn from_key(key: &Self::Key, _device: Option<&Retained<ProtocolObject<dyn MTLDevice>>>) -> Result<Self, MetalError> {
        let data_type: MPSDataType = key.dtype.into();
        let accumulator_type = key.accumulator_dtype.map(Into::into);

        let _builder = MultiOpGraphBuilder::new(data_type)?;

        let feed_layout = Vec::new();
        let result_layout = Vec::new();

        let graph = unsafe { mpsg::MPSGraph::new() };
        let feed_types: Retained<NSMutableDictionary<mpsg::MPSGraphTensor, mpsg::MPSGraphShapedType>> = NSMutableDictionary::dictionary();
        let target_tensor_list: Retained<NSMutableArray<mpsg::MPSGraphTensor>> = NSMutableArray::array();
        let target_tensor_array: Retained<NSArray<mpsg::MPSGraphTensor>> = unsafe { Retained::cast_unchecked(target_tensor_list) };
        let feed_types_dict: Retained<objc2_foundation::NSDictionary<mpsg::MPSGraphTensor, mpsg::MPSGraphShapedType>> =
            unsafe { Retained::cast_unchecked(feed_types) };

        let executable = unsafe {
            graph.compileWithDevice_feeds_targetTensors_targetOperations_compilationDescriptor(
                None,
                &feed_types_dict,
                &target_tensor_array,
                None,
                None,
            )
        };

        Ok(Self {
            key: key.clone(),
            executable,
            feed_layout,
            result_layout,
            data_type,
            accumulator_data_type: accumulator_type,
        })
    }
}

/// Cache adapter for fused MPSGraph executables generated by the multi-op builder.
pub struct MpsGraphFusedKernel;

impl CacheableKernel for MpsGraphFusedKernel {
    type Key = MpsGraphFusedKey;
    type CachedResource = CacheableMpsGraphFused;
    type Params = MpsGraphFusedKey;

    const CACHE_NAME: &'static str = "mpsgraph_fused";

    #[inline]
    fn create_cache_key(params: &Self::Params) -> Self::Key {
        params.clone()
    }

    #[inline]
    fn create_cached_resource(
        key: &Self::Key,
        device: Option<&Retained<ProtocolObject<dyn MTLDevice>>>,
    ) -> Result<Self::CachedResource, MetalError> {
        CacheableMpsGraphFused::from_key(key, device)
    }
}
