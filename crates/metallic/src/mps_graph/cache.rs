use std::hash::{Hash, Hasher};

use objc2::{rc::Retained, runtime::ProtocolObject};
use objc2_foundation::{NSArray, NSMutableArray, NSMutableDictionary};
use objc2_metal::MTLDevice;
use objc2_metal_performance_shaders::MPSDataType;
use objc2_metal_performance_shaders_graph as mpsg;
use serde::{Deserialize, Serialize};

use crate::{
    caching::CacheableKernel, error::MetalError, mps_graph::multi_op::{GraphFeedBinding, GraphResultBinding, MultiOpGraphBuilder}, tensor::dtypes::Dtype
};

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum FusedOperationType {
    SdpaProjection,
}

/// Key for MPSGraph fused operations.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MpsGraphFusedKey {
    pub batch: usize,
    pub seq_q: usize,
    pub seq_k: usize,
    pub dim: usize,
    pub output_dim: usize,
    pub causal: bool,
    pub dtype: Dtype,
    pub operation_type: FusedOperationType,
    pub accumulator_dtype: Option<Dtype>,
}

impl PartialEq for MpsGraphFusedKey {
    fn eq(&self, other: &Self) -> bool {
        self.batch == other.batch
            && self.seq_q == other.seq_q
            && self.seq_k == other.seq_k
            && self.dim == other.dim
            && self.output_dim == other.output_dim
            && self.causal == other.causal
            && self.dtype == other.dtype
            && self.operation_type == other.operation_type
            && self.accumulator_dtype == other.accumulator_dtype
    }
}

impl Eq for MpsGraphFusedKey {}

impl Hash for MpsGraphFusedKey {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.batch.hash(state);
        self.seq_q.hash(state);
        self.seq_k.hash(state);
        self.dim.hash(state);
        self.output_dim.hash(state);
        self.causal.hash(state);
        self.dtype.hash(state);
        self.operation_type.hash(state);
        self.accumulator_dtype.hash(state);
    }
}

#[derive(Clone)]
pub struct CacheableMpsGraphFused {
    pub key: MpsGraphFusedKey,
    pub executable: Retained<mpsg::MPSGraphExecutable>,
    pub feed_layout: Vec<GraphFeedBinding>,
    pub result_layout: Vec<GraphResultBinding>,
    pub data_type: MPSDataType,
    pub accumulator_data_type: Option<MPSDataType>,
}

impl CacheableMpsGraphFused {
    pub fn key(&self) -> &MpsGraphFusedKey {
        &self.key
    }

    pub fn from_key(key: &MpsGraphFusedKey, _device: Option<&Retained<ProtocolObject<dyn MTLDevice>>>) -> Result<Self, MetalError> {
        let data_type: MPSDataType = key.dtype.into();
        let accumulator_type = key.accumulator_dtype.map(Into::into);

        let _builder = MultiOpGraphBuilder::new(data_type)?;

        let feed_layout = Vec::new();
        let result_layout = Vec::new();

        let graph = unsafe { mpsg::MPSGraph::new() };
        let feed_types: Retained<NSMutableDictionary<mpsg::MPSGraphTensor, mpsg::MPSGraphShapedType>> = NSMutableDictionary::dictionary();
        let target_tensor_list: Retained<NSMutableArray<mpsg::MPSGraphTensor>> = NSMutableArray::array();
        let target_tensor_array: Retained<NSArray<mpsg::MPSGraphTensor>> = unsafe { Retained::cast_unchecked(target_tensor_list) };
        let feed_types_dict: Retained<objc2_foundation::NSDictionary<mpsg::MPSGraphTensor, mpsg::MPSGraphShapedType>> =
            unsafe { Retained::cast_unchecked(feed_types) };

        let executable = unsafe {
            graph.compileWithDevice_feeds_targetTensors_targetOperations_compilationDescriptor(
                None,
                &feed_types_dict,
                &target_tensor_array,
                None,
                None,
            )
        };

        Ok(Self {
            key: key.clone(),
            executable,
            feed_layout,
            result_layout,
            data_type,
            accumulator_data_type: accumulator_type,
        })
    }
}

/// Cache adapter for fused MPSGraph executables generated by the multi-op builder.
pub struct MpsGraphFusedKernel;

impl CacheableKernel for MpsGraphFusedKernel {
    type Key = MpsGraphFusedKey;
    type CachedResource = CacheableMpsGraphFused;
    type Params = MpsGraphFusedKey;

    const CACHE_NAME: &'static str = "mpsgraph_fused";

    #[inline]
    fn create_cache_key(params: &Self::Params) -> Self::Key {
        params.clone()
    }

    #[inline]
    fn create_cached_resource(
        key: &Self::Key,
        device: Option<&Retained<ProtocolObject<dyn MTLDevice>>>,
    ) -> Result<Self::CachedResource, MetalError> {
        CacheableMpsGraphFused::from_key(key, device)
    }
}
