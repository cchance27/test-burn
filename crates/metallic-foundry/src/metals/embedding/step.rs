use std::sync::Arc;

use metallic_macros::{KernelArgs, Stage as DeriveStage};

use crate::{
    Foundry, MetalError, compound::CompiledCompoundKernel, fusion::MetalPolicy, metals::{
        common::{cache::get_or_build_policy_compound_kernel, composition::manual_output}, embedding::{EmbeddingParams, EmbeddingParamsResolved}
    }, spec::{CompiledStep, FastBindings, SymbolTable, TensorBindings}, types::{DispatchConfig, GridSize, TensorArg}
};

// Note: EmbeddingStep and CompiledEmbeddingStep are auto-generated by #[derive(Kernel)] in mod.rs

impl CompiledStep for super::CompiledEmbeddingStep {
    fn execute(
        &self,
        foundry: &mut Foundry,
        fast_bindings: &FastBindings,
        bindings: &TensorBindings,
        _symbols: &SymbolTable,
    ) -> Result<(), MetalError> {
        let table = fast_bindings
            .get(self.table)
            .ok_or_else(|| MetalError::InputNotFound("embedding table".into()))?;
        let indices = fast_bindings
            .get(self.indices)
            .ok_or_else(|| MetalError::InputNotFound("embedding indices".into()))?;
        let output = fast_bindings
            .get(self.output)
            .ok_or_else(|| MetalError::InputNotFound("embedding output".into()))?;

        // Derived scales: generated as `usize` index by macro via `scale_for`
        // Validation: If table is Q8, `scale_for` tensor must exist.
        // If table is F16, `scale_for` tensor might not exist (Optional in CompiledStep?).
        // Wait, I made it `TensorArg` (mandatory) in CompiledStep generation if I used regular logic.
        // But `symbols.get_or_create` ALWAYS creates an index.
        // So `self.scale_bytes` is a valid usize index.
        // `fast_bindings.get(idx)` returns `Option<&Tensor>`.
        // If unbound, it returns None.
        // Fallback to table (dummy) if None.
        let scale_bytes = fast_bindings.get(self.scale_bytes).unwrap_or(table);

        let params = EmbeddingParamsResolved {
            d_model: self.params.d_model.resolve(bindings),
            total_elements: self.params.total_elements.resolve(bindings),
            vocab_size: self.params.vocab_size.resolve(bindings),
        };

        let policy = crate::policy::resolve_policy(table.dtype);
        // Note: we don't use policy.loader() here, we bind directly.
        // But execute logic is consistent with creating a CompoundKernel.

        let args = EmbeddingGenericArgs {
            table: TensorArg::from_tensor(table),
            scale_bytes: TensorArg::from_tensor(scale_bytes),
            indices: TensorArg::from_tensor(indices),
            output: TensorArg::from_tensor(output),
            params,
        };

        let kernel = get_embedding_kernel(policy);
        let dispatch = DispatchConfig {
            grid: GridSize::d1(params.total_elements as usize),
            group: crate::types::ThreadgroupSize::d1(256),
        };

        foundry.run(&kernel.bind_arc(args, dispatch))?;
        Ok(())
    }

    fn name(&self) -> &'static str {
        "Embedding"
    }
}

#[derive(Debug, Clone, KernelArgs)]
pub struct EmbeddingGenericArgs {
    #[arg(metal_type = "const device uchar*")]
    pub table: TensorArg,
    #[arg(metal_type = "const device uchar*")]
    pub scale_bytes: TensorArg,
    #[arg(metal_type = "const device uint*")]
    pub indices: TensorArg,
    #[arg(output, metal_type = "device OutputStorageT*")]
    pub output: TensorArg,
    pub params: EmbeddingParamsResolved,
}

#[derive(Debug, Clone, KernelArgs, DeriveStage)]
#[stage(
    includes("embedding/embedding.metal"),
    include_exprs("self.policy.header()"),
    struct_defs = "EmbeddingParams",
    template_bindings(policy_struct = "self.policy.struct_name()"),
    emit = r#"
    run_embedding_core<{policy_struct}>(table, scale_bytes, indices, output, params, gid.x);
"#,
    out_var = "output"
)]
pub struct EmbeddingStage {
    #[arg(buffer = 0, metal_type = "const device uchar*")]
    pub table: TensorArg,
    #[arg(buffer = 1, metal_type = "const device uchar*")]
    pub scale_bytes: TensorArg,
    #[arg(buffer = 2, metal_type = "const device uint*")]
    pub indices: TensorArg,
    #[arg(buffer = 3, output, metal_type = "device OutputStorageT*")]
    pub output: TensorArg,
    #[arg(buffer = 4, metal_type = "constant EmbeddingParams*")]
    pub params: EmbeddingParamsResolved,
    #[arg(skip, stage_skip)]
    pub policy: Arc<dyn MetalPolicy>,
}

impl Default for EmbeddingStage {
    fn default() -> Self {
        Self {
            table: TensorArg::default(),
            scale_bytes: TensorArg::default(),
            indices: TensorArg::default(),
            output: TensorArg::default(),
            params: EmbeddingParamsResolved::default(),
            policy: Arc::new(crate::policy::f16::PolicyF16),
        }
    }
}

pub fn get_embedding_kernel(policy: Arc<dyn MetalPolicy>) -> Arc<CompiledCompoundKernel> {
    get_or_build_policy_compound_kernel("embedding", policy, |policy| {
        let dummy_params = EmbeddingParamsResolved {
            d_model: 0,
            total_elements: 0,
            vocab_size: 0,
        };
        let stage = EmbeddingStage {
            params: dummy_params,
            policy: policy.clone(),
            ..Default::default()
        };

        let kernel_name = format!("embedding_standalone_{}", policy.short_name());
        manual_output(&kernel_name).main(stage).compile()
    })
}
